// Code generated by protoc-gen-gogo.
// source: group_api.proto
// DO NOT EDIT!

/*
	Package groupproto is a generated protocol buffer package.

	It is generated from these files:
		group_api.proto

	It has these top-level messages:
		EmptyMsg
		WriteRequest
		LookupRequest
		ReadRequest
		DeleteRequest
		LookupGroupRequest
		ReadGroupRequest
		WriteResponse
		LookupResponse
		LookupGroupResponse
		LookupGroupItem
		ReadGroupResponse
		ReadGroupItem
		ReadResponse
		DeleteResponse
*/
package groupproto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type EmptyMsg struct {
}

func (m *EmptyMsg) Reset()                    { *m = EmptyMsg{} }
func (m *EmptyMsg) String() string            { return proto.CompactTextString(m) }
func (*EmptyMsg) ProtoMessage()               {}
func (*EmptyMsg) Descriptor() ([]byte, []int) { return fileDescriptorGroupApi, []int{0} }

type WriteRequest struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	KeyA           uint64 `protobuf:"varint,2,opt,name=keyA,proto3" json:"keyA,omitempty"`
	KeyB           uint64 `protobuf:"varint,3,opt,name=keyB,proto3" json:"keyB,omitempty"`
	ChildKeyA      uint64 `protobuf:"varint,4,opt,name=childKeyA,proto3" json:"childKeyA,omitempty"`
	ChildKeyB      uint64 `protobuf:"varint,5,opt,name=childKeyB,proto3" json:"childKeyB,omitempty"`
	Value          []byte `protobuf:"bytes,6,opt,name=value,proto3" json:"value,omitempty"`
	TimestampMicro int64  `protobuf:"varint,7,opt,name=timestampMicro,proto3" json:"timestampMicro,omitempty"`
}

func (m *WriteRequest) Reset()                    { *m = WriteRequest{} }
func (m *WriteRequest) String() string            { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()               {}
func (*WriteRequest) Descriptor() ([]byte, []int) { return fileDescriptorGroupApi, []int{1} }

type LookupRequest struct {
	Rpcid     uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	KeyA      uint64 `protobuf:"varint,2,opt,name=keyA,proto3" json:"keyA,omitempty"`
	KeyB      uint64 `protobuf:"varint,3,opt,name=keyB,proto3" json:"keyB,omitempty"`
	ChildKeyA uint64 `protobuf:"varint,4,opt,name=childKeyA,proto3" json:"childKeyA,omitempty"`
	ChildKeyB uint64 `protobuf:"varint,5,opt,name=childKeyB,proto3" json:"childKeyB,omitempty"`
}

func (m *LookupRequest) Reset()                    { *m = LookupRequest{} }
func (m *LookupRequest) String() string            { return proto.CompactTextString(m) }
func (*LookupRequest) ProtoMessage()               {}
func (*LookupRequest) Descriptor() ([]byte, []int) { return fileDescriptorGroupApi, []int{2} }

type ReadRequest struct {
	Rpcid     uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	KeyA      uint64 `protobuf:"varint,2,opt,name=keyA,proto3" json:"keyA,omitempty"`
	KeyB      uint64 `protobuf:"varint,3,opt,name=keyB,proto3" json:"keyB,omitempty"`
	ChildKeyA uint64 `protobuf:"varint,4,opt,name=childKeyA,proto3" json:"childKeyA,omitempty"`
	ChildKeyB uint64 `protobuf:"varint,5,opt,name=childKeyB,proto3" json:"childKeyB,omitempty"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (m *ReadRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptorGroupApi, []int{3} }

type DeleteRequest struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	KeyA           uint64 `protobuf:"varint,2,opt,name=keyA,proto3" json:"keyA,omitempty"`
	KeyB           uint64 `protobuf:"varint,3,opt,name=keyB,proto3" json:"keyB,omitempty"`
	ChildKeyA      uint64 `protobuf:"varint,4,opt,name=childKeyA,proto3" json:"childKeyA,omitempty"`
	ChildKeyB      uint64 `protobuf:"varint,5,opt,name=childKeyB,proto3" json:"childKeyB,omitempty"`
	TimestampMicro int64  `protobuf:"varint,6,opt,name=timestampMicro,proto3" json:"timestampMicro,omitempty"`
}

func (m *DeleteRequest) Reset()                    { *m = DeleteRequest{} }
func (m *DeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteRequest) ProtoMessage()               {}
func (*DeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptorGroupApi, []int{4} }

type LookupGroupRequest struct {
	Rpcid uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	KeyA  uint64 `protobuf:"varint,2,opt,name=keyA,proto3" json:"keyA,omitempty"`
	KeyB  uint64 `protobuf:"varint,3,opt,name=keyB,proto3" json:"keyB,omitempty"`
}

func (m *LookupGroupRequest) Reset()                    { *m = LookupGroupRequest{} }
func (m *LookupGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*LookupGroupRequest) ProtoMessage()               {}
func (*LookupGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptorGroupApi, []int{5} }

type ReadGroupRequest struct {
	Rpcid uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	KeyA  uint64 `protobuf:"varint,2,opt,name=keyA,proto3" json:"keyA,omitempty"`
	KeyB  uint64 `protobuf:"varint,3,opt,name=keyB,proto3" json:"keyB,omitempty"`
}

func (m *ReadGroupRequest) Reset()                    { *m = ReadGroupRequest{} }
func (m *ReadGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadGroupRequest) ProtoMessage()               {}
func (*ReadGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptorGroupApi, []int{6} }

type WriteResponse struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	TimestampMicro int64  `protobuf:"varint,2,opt,name=timestampMicro,proto3" json:"timestampMicro,omitempty"`
	Err            string `protobuf:"bytes,3,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *WriteResponse) Reset()                    { *m = WriteResponse{} }
func (m *WriteResponse) String() string            { return proto.CompactTextString(m) }
func (*WriteResponse) ProtoMessage()               {}
func (*WriteResponse) Descriptor() ([]byte, []int) { return fileDescriptorGroupApi, []int{7} }

type LookupResponse struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	TimestampMicro int64  `protobuf:"varint,2,opt,name=timestampMicro,proto3" json:"timestampMicro,omitempty"`
	Length         uint32 `protobuf:"varint,3,opt,name=length,proto3" json:"length,omitempty"`
	Err            string `protobuf:"bytes,4,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *LookupResponse) Reset()                    { *m = LookupResponse{} }
func (m *LookupResponse) String() string            { return proto.CompactTextString(m) }
func (*LookupResponse) ProtoMessage()               {}
func (*LookupResponse) Descriptor() ([]byte, []int) { return fileDescriptorGroupApi, []int{8} }

type LookupGroupResponse struct {
	Rpcid uint32             `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	Items []*LookupGroupItem `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
	Err   string             `protobuf:"bytes,3,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *LookupGroupResponse) Reset()                    { *m = LookupGroupResponse{} }
func (m *LookupGroupResponse) String() string            { return proto.CompactTextString(m) }
func (*LookupGroupResponse) ProtoMessage()               {}
func (*LookupGroupResponse) Descriptor() ([]byte, []int) { return fileDescriptorGroupApi, []int{9} }

func (m *LookupGroupResponse) GetItems() []*LookupGroupItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type LookupGroupItem struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	ChildKeyA      uint64 `protobuf:"varint,2,opt,name=childKeyA,proto3" json:"childKeyA,omitempty"`
	ChildKeyB      uint64 `protobuf:"varint,3,opt,name=childKeyB,proto3" json:"childKeyB,omitempty"`
	TimestampMicro int64  `protobuf:"varint,4,opt,name=timestampMicro,proto3" json:"timestampMicro,omitempty"`
	Length         uint32 `protobuf:"varint,5,opt,name=length,proto3" json:"length,omitempty"`
}

func (m *LookupGroupItem) Reset()                    { *m = LookupGroupItem{} }
func (m *LookupGroupItem) String() string            { return proto.CompactTextString(m) }
func (*LookupGroupItem) ProtoMessage()               {}
func (*LookupGroupItem) Descriptor() ([]byte, []int) { return fileDescriptorGroupApi, []int{10} }

type ReadGroupResponse struct {
	Rpcid uint32           `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	Items []*ReadGroupItem `protobuf:"bytes,2,rep,name=items" json:"items,omitempty"`
	Err   string           `protobuf:"bytes,3,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *ReadGroupResponse) Reset()                    { *m = ReadGroupResponse{} }
func (m *ReadGroupResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadGroupResponse) ProtoMessage()               {}
func (*ReadGroupResponse) Descriptor() ([]byte, []int) { return fileDescriptorGroupApi, []int{11} }

func (m *ReadGroupResponse) GetItems() []*ReadGroupItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type ReadGroupItem struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	ChildKeyA      uint64 `protobuf:"varint,2,opt,name=childKeyA,proto3" json:"childKeyA,omitempty"`
	ChildKeyB      uint64 `protobuf:"varint,3,opt,name=childKeyB,proto3" json:"childKeyB,omitempty"`
	TimestampMicro int64  `protobuf:"varint,4,opt,name=timestampMicro,proto3" json:"timestampMicro,omitempty"`
	Value          []byte `protobuf:"bytes,5,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ReadGroupItem) Reset()                    { *m = ReadGroupItem{} }
func (m *ReadGroupItem) String() string            { return proto.CompactTextString(m) }
func (*ReadGroupItem) ProtoMessage()               {}
func (*ReadGroupItem) Descriptor() ([]byte, []int) { return fileDescriptorGroupApi, []int{12} }

type ReadResponse struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	TimestampMicro int64  `protobuf:"varint,2,opt,name=timestampMicro,proto3" json:"timestampMicro,omitempty"`
	Value          []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Err            string `protobuf:"bytes,4,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *ReadResponse) Reset()                    { *m = ReadResponse{} }
func (m *ReadResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadResponse) ProtoMessage()               {}
func (*ReadResponse) Descriptor() ([]byte, []int) { return fileDescriptorGroupApi, []int{13} }

type DeleteResponse struct {
	Rpcid          uint32 `protobuf:"varint,1,opt,name=rpcid,proto3" json:"rpcid,omitempty"`
	TimestampMicro int64  `protobuf:"varint,2,opt,name=timestampMicro,proto3" json:"timestampMicro,omitempty"`
	Err            string `protobuf:"bytes,3,opt,name=err,proto3" json:"err,omitempty"`
}

func (m *DeleteResponse) Reset()                    { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()               {}
func (*DeleteResponse) Descriptor() ([]byte, []int) { return fileDescriptorGroupApi, []int{14} }

func init() {
	proto.RegisterType((*EmptyMsg)(nil), "groupproto.EmptyMsg")
	proto.RegisterType((*WriteRequest)(nil), "groupproto.WriteRequest")
	proto.RegisterType((*LookupRequest)(nil), "groupproto.LookupRequest")
	proto.RegisterType((*ReadRequest)(nil), "groupproto.ReadRequest")
	proto.RegisterType((*DeleteRequest)(nil), "groupproto.DeleteRequest")
	proto.RegisterType((*LookupGroupRequest)(nil), "groupproto.LookupGroupRequest")
	proto.RegisterType((*ReadGroupRequest)(nil), "groupproto.ReadGroupRequest")
	proto.RegisterType((*WriteResponse)(nil), "groupproto.WriteResponse")
	proto.RegisterType((*LookupResponse)(nil), "groupproto.LookupResponse")
	proto.RegisterType((*LookupGroupResponse)(nil), "groupproto.LookupGroupResponse")
	proto.RegisterType((*LookupGroupItem)(nil), "groupproto.LookupGroupItem")
	proto.RegisterType((*ReadGroupResponse)(nil), "groupproto.ReadGroupResponse")
	proto.RegisterType((*ReadGroupItem)(nil), "groupproto.ReadGroupItem")
	proto.RegisterType((*ReadResponse)(nil), "groupproto.ReadResponse")
	proto.RegisterType((*DeleteResponse)(nil), "groupproto.DeleteResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for GroupStore service

type GroupStoreClient interface {
	Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error)
	StreamWrite(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamWriteClient, error)
	Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupResponse, error)
	StreamLookup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamLookupClient, error)
	LookupGroup(ctx context.Context, in *LookupGroupRequest, opts ...grpc.CallOption) (*LookupGroupResponse, error)
	StreamLookupGroup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamLookupGroupClient, error)
	ReadGroup(ctx context.Context, in *ReadGroupRequest, opts ...grpc.CallOption) (*ReadGroupResponse, error)
	StreamReadGroup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamReadGroupClient, error)
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error)
	StreamRead(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamReadClient, error)
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	StreamDelete(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamDeleteClient, error)
}

type groupStoreClient struct {
	cc *grpc.ClientConn
}

func NewGroupStoreClient(cc *grpc.ClientConn) GroupStoreClient {
	return &groupStoreClient{cc}
}

func (c *groupStoreClient) Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteResponse, error) {
	out := new(WriteResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/Write", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamWrite(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamWriteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[0], c.cc, "/groupproto.GroupStore/StreamWrite", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamWriteClient{stream}
	return x, nil
}

type GroupStore_StreamWriteClient interface {
	Send(*WriteRequest) error
	Recv() (*WriteResponse, error)
	grpc.ClientStream
}

type groupStoreStreamWriteClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamWriteClient) Send(m *WriteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamWriteClient) Recv() (*WriteResponse, error) {
	m := new(WriteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *groupStoreClient) Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupResponse, error) {
	out := new(LookupResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/Lookup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamLookup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamLookupClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[1], c.cc, "/groupproto.GroupStore/StreamLookup", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamLookupClient{stream}
	return x, nil
}

type GroupStore_StreamLookupClient interface {
	Send(*LookupRequest) error
	Recv() (*LookupResponse, error)
	grpc.ClientStream
}

type groupStoreStreamLookupClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamLookupClient) Send(m *LookupRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamLookupClient) Recv() (*LookupResponse, error) {
	m := new(LookupResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *groupStoreClient) LookupGroup(ctx context.Context, in *LookupGroupRequest, opts ...grpc.CallOption) (*LookupGroupResponse, error) {
	out := new(LookupGroupResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/LookupGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamLookupGroup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamLookupGroupClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[2], c.cc, "/groupproto.GroupStore/StreamLookupGroup", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamLookupGroupClient{stream}
	return x, nil
}

type GroupStore_StreamLookupGroupClient interface {
	Send(*LookupGroupRequest) error
	Recv() (*LookupGroupResponse, error)
	grpc.ClientStream
}

type groupStoreStreamLookupGroupClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamLookupGroupClient) Send(m *LookupGroupRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamLookupGroupClient) Recv() (*LookupGroupResponse, error) {
	m := new(LookupGroupResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *groupStoreClient) ReadGroup(ctx context.Context, in *ReadGroupRequest, opts ...grpc.CallOption) (*ReadGroupResponse, error) {
	out := new(ReadGroupResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/ReadGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamReadGroup(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamReadGroupClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[3], c.cc, "/groupproto.GroupStore/StreamReadGroup", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamReadGroupClient{stream}
	return x, nil
}

type GroupStore_StreamReadGroupClient interface {
	Send(*ReadGroupRequest) error
	Recv() (*ReadGroupResponse, error)
	grpc.ClientStream
}

type groupStoreStreamReadGroupClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamReadGroupClient) Send(m *ReadGroupRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamReadGroupClient) Recv() (*ReadGroupResponse, error) {
	m := new(ReadGroupResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *groupStoreClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (*ReadResponse, error) {
	out := new(ReadResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/Read", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamRead(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamReadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[4], c.cc, "/groupproto.GroupStore/StreamRead", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamReadClient{stream}
	return x, nil
}

type GroupStore_StreamReadClient interface {
	Send(*ReadRequest) error
	Recv() (*ReadResponse, error)
	grpc.ClientStream
}

type groupStoreStreamReadClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamReadClient) Send(m *ReadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamReadClient) Recv() (*ReadResponse, error) {
	m := new(ReadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *groupStoreClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := grpc.Invoke(ctx, "/groupproto.GroupStore/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupStoreClient) StreamDelete(ctx context.Context, opts ...grpc.CallOption) (GroupStore_StreamDeleteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GroupStore_serviceDesc.Streams[5], c.cc, "/groupproto.GroupStore/StreamDelete", opts...)
	if err != nil {
		return nil, err
	}
	x := &groupStoreStreamDeleteClient{stream}
	return x, nil
}

type GroupStore_StreamDeleteClient interface {
	Send(*DeleteRequest) error
	Recv() (*DeleteResponse, error)
	grpc.ClientStream
}

type groupStoreStreamDeleteClient struct {
	grpc.ClientStream
}

func (x *groupStoreStreamDeleteClient) Send(m *DeleteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *groupStoreStreamDeleteClient) Recv() (*DeleteResponse, error) {
	m := new(DeleteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for GroupStore service

type GroupStoreServer interface {
	Write(context.Context, *WriteRequest) (*WriteResponse, error)
	StreamWrite(GroupStore_StreamWriteServer) error
	Lookup(context.Context, *LookupRequest) (*LookupResponse, error)
	StreamLookup(GroupStore_StreamLookupServer) error
	LookupGroup(context.Context, *LookupGroupRequest) (*LookupGroupResponse, error)
	StreamLookupGroup(GroupStore_StreamLookupGroupServer) error
	ReadGroup(context.Context, *ReadGroupRequest) (*ReadGroupResponse, error)
	StreamReadGroup(GroupStore_StreamReadGroupServer) error
	Read(context.Context, *ReadRequest) (*ReadResponse, error)
	StreamRead(GroupStore_StreamReadServer) error
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	StreamDelete(GroupStore_StreamDeleteServer) error
}

func RegisterGroupStoreServer(s *grpc.Server, srv GroupStoreServer) {
	s.RegisterService(&_GroupStore_serviceDesc, srv)
}

func _GroupStore_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupStoreServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupproto.GroupStore/Write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupStoreServer).Write(ctx, req.(*WriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupStore_StreamWrite_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamWrite(&groupStoreStreamWriteServer{stream})
}

type GroupStore_StreamWriteServer interface {
	Send(*WriteResponse) error
	Recv() (*WriteRequest, error)
	grpc.ServerStream
}

type groupStoreStreamWriteServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamWriteServer) Send(m *WriteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamWriteServer) Recv() (*WriteRequest, error) {
	m := new(WriteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GroupStore_Lookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupStoreServer).Lookup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupproto.GroupStore/Lookup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupStoreServer).Lookup(ctx, req.(*LookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupStore_StreamLookup_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamLookup(&groupStoreStreamLookupServer{stream})
}

type GroupStore_StreamLookupServer interface {
	Send(*LookupResponse) error
	Recv() (*LookupRequest, error)
	grpc.ServerStream
}

type groupStoreStreamLookupServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamLookupServer) Send(m *LookupResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamLookupServer) Recv() (*LookupRequest, error) {
	m := new(LookupRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GroupStore_LookupGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookupGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupStoreServer).LookupGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupproto.GroupStore/LookupGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupStoreServer).LookupGroup(ctx, req.(*LookupGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupStore_StreamLookupGroup_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamLookupGroup(&groupStoreStreamLookupGroupServer{stream})
}

type GroupStore_StreamLookupGroupServer interface {
	Send(*LookupGroupResponse) error
	Recv() (*LookupGroupRequest, error)
	grpc.ServerStream
}

type groupStoreStreamLookupGroupServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamLookupGroupServer) Send(m *LookupGroupResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamLookupGroupServer) Recv() (*LookupGroupRequest, error) {
	m := new(LookupGroupRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GroupStore_ReadGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupStoreServer).ReadGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupproto.GroupStore/ReadGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupStoreServer).ReadGroup(ctx, req.(*ReadGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupStore_StreamReadGroup_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamReadGroup(&groupStoreStreamReadGroupServer{stream})
}

type GroupStore_StreamReadGroupServer interface {
	Send(*ReadGroupResponse) error
	Recv() (*ReadGroupRequest, error)
	grpc.ServerStream
}

type groupStoreStreamReadGroupServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamReadGroupServer) Send(m *ReadGroupResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamReadGroupServer) Recv() (*ReadGroupRequest, error) {
	m := new(ReadGroupRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GroupStore_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupStoreServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupproto.GroupStore/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupStoreServer).Read(ctx, req.(*ReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupStore_StreamRead_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamRead(&groupStoreStreamReadServer{stream})
}

type GroupStore_StreamReadServer interface {
	Send(*ReadResponse) error
	Recv() (*ReadRequest, error)
	grpc.ServerStream
}

type groupStoreStreamReadServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamReadServer) Send(m *ReadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamReadServer) Recv() (*ReadRequest, error) {
	m := new(ReadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GroupStore_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupStoreServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupproto.GroupStore/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupStoreServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupStore_StreamDelete_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupStoreServer).StreamDelete(&groupStoreStreamDeleteServer{stream})
}

type GroupStore_StreamDeleteServer interface {
	Send(*DeleteResponse) error
	Recv() (*DeleteRequest, error)
	grpc.ServerStream
}

type groupStoreStreamDeleteServer struct {
	grpc.ServerStream
}

func (x *groupStoreStreamDeleteServer) Send(m *DeleteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *groupStoreStreamDeleteServer) Recv() (*DeleteRequest, error) {
	m := new(DeleteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _GroupStore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "groupproto.GroupStore",
	HandlerType: (*GroupStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Write",
			Handler:    _GroupStore_Write_Handler,
		},
		{
			MethodName: "Lookup",
			Handler:    _GroupStore_Lookup_Handler,
		},
		{
			MethodName: "LookupGroup",
			Handler:    _GroupStore_LookupGroup_Handler,
		},
		{
			MethodName: "ReadGroup",
			Handler:    _GroupStore_ReadGroup_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _GroupStore_Read_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _GroupStore_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamWrite",
			Handler:       _GroupStore_StreamWrite_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamLookup",
			Handler:       _GroupStore_StreamLookup_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamLookupGroup",
			Handler:       _GroupStore_StreamLookupGroup_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamReadGroup",
			Handler:       _GroupStore_StreamReadGroup_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamRead",
			Handler:       _GroupStore_StreamRead_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamDelete",
			Handler:       _GroupStore_StreamDelete_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: fileDescriptorGroupApi,
}

func (m *EmptyMsg) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EmptyMsg) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *WriteRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WriteRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyB))
	}
	if m.ChildKeyA != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyB))
	}
	if len(m.Value) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintGroupApi(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	if m.TimestampMicro != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.TimestampMicro))
	}
	return i, nil
}

func (m *LookupRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LookupRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyB))
	}
	if m.ChildKeyA != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyB))
	}
	return i, nil
}

func (m *ReadRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReadRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyB))
	}
	if m.ChildKeyA != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyB))
	}
	return i, nil
}

func (m *DeleteRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeleteRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyB))
	}
	if m.ChildKeyA != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyB))
	}
	if m.TimestampMicro != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.TimestampMicro))
	}
	return i, nil
}

func (m *LookupGroupRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LookupGroupRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyB))
	}
	return i, nil
}

func (m *ReadGroupRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReadGroupRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.KeyB))
	}
	return i, nil
}

func (m *WriteResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WriteResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.TimestampMicro != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.TimestampMicro))
	}
	if len(m.Err) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintGroupApi(data, i, uint64(len(m.Err)))
		i += copy(data[i:], m.Err)
	}
	return i, nil
}

func (m *LookupResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LookupResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.TimestampMicro != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.TimestampMicro))
	}
	if m.Length != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Length))
	}
	if len(m.Err) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintGroupApi(data, i, uint64(len(m.Err)))
		i += copy(data[i:], m.Err)
	}
	return i, nil
}

func (m *LookupGroupResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LookupGroupResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0x12
			i++
			i = encodeVarintGroupApi(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Err) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintGroupApi(data, i, uint64(len(m.Err)))
		i += copy(data[i:], m.Err)
	}
	return i, nil
}

func (m *LookupGroupItem) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LookupGroupItem) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.ChildKeyA != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyB))
	}
	if m.TimestampMicro != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.TimestampMicro))
	}
	if m.Length != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Length))
	}
	return i, nil
}

func (m *ReadGroupResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReadGroupResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0x12
			i++
			i = encodeVarintGroupApi(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Err) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintGroupApi(data, i, uint64(len(m.Err)))
		i += copy(data[i:], m.Err)
	}
	return i, nil
}

func (m *ReadGroupItem) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReadGroupItem) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.ChildKeyA != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.ChildKeyB))
	}
	if m.TimestampMicro != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.TimestampMicro))
	}
	if len(m.Value) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintGroupApi(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	return i, nil
}

func (m *ReadResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReadResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.TimestampMicro != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.TimestampMicro))
	}
	if len(m.Value) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintGroupApi(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	if len(m.Err) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintGroupApi(data, i, uint64(len(m.Err)))
		i += copy(data[i:], m.Err)
	}
	return i, nil
}

func (m *DeleteResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeleteResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rpcid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.Rpcid))
	}
	if m.TimestampMicro != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintGroupApi(data, i, uint64(m.TimestampMicro))
	}
	if len(m.Err) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintGroupApi(data, i, uint64(len(m.Err)))
		i += copy(data[i:], m.Err)
	}
	return i, nil
}

func encodeFixed64GroupApi(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32GroupApi(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintGroupApi(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *EmptyMsg) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *WriteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyB))
	}
	if m.ChildKeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyB))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovGroupApi(uint64(l))
	}
	if m.TimestampMicro != 0 {
		n += 1 + sovGroupApi(uint64(m.TimestampMicro))
	}
	return n
}

func (m *LookupRequest) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyB))
	}
	if m.ChildKeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyB))
	}
	return n
}

func (m *ReadRequest) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyB))
	}
	if m.ChildKeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyB))
	}
	return n
}

func (m *DeleteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyB))
	}
	if m.ChildKeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyB))
	}
	if m.TimestampMicro != 0 {
		n += 1 + sovGroupApi(uint64(m.TimestampMicro))
	}
	return n
}

func (m *LookupGroupRequest) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyB))
	}
	return n
}

func (m *ReadGroupRequest) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.KeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyA))
	}
	if m.KeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.KeyB))
	}
	return n
}

func (m *WriteResponse) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.TimestampMicro != 0 {
		n += 1 + sovGroupApi(uint64(m.TimestampMicro))
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovGroupApi(uint64(l))
	}
	return n
}

func (m *LookupResponse) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.TimestampMicro != 0 {
		n += 1 + sovGroupApi(uint64(m.TimestampMicro))
	}
	if m.Length != 0 {
		n += 1 + sovGroupApi(uint64(m.Length))
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovGroupApi(uint64(l))
	}
	return n
}

func (m *LookupGroupResponse) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGroupApi(uint64(l))
		}
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovGroupApi(uint64(l))
	}
	return n
}

func (m *LookupGroupItem) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.ChildKeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyB))
	}
	if m.TimestampMicro != 0 {
		n += 1 + sovGroupApi(uint64(m.TimestampMicro))
	}
	if m.Length != 0 {
		n += 1 + sovGroupApi(uint64(m.Length))
	}
	return n
}

func (m *ReadGroupResponse) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovGroupApi(uint64(l))
		}
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovGroupApi(uint64(l))
	}
	return n
}

func (m *ReadGroupItem) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.ChildKeyA != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyA))
	}
	if m.ChildKeyB != 0 {
		n += 1 + sovGroupApi(uint64(m.ChildKeyB))
	}
	if m.TimestampMicro != 0 {
		n += 1 + sovGroupApi(uint64(m.TimestampMicro))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovGroupApi(uint64(l))
	}
	return n
}

func (m *ReadResponse) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.TimestampMicro != 0 {
		n += 1 + sovGroupApi(uint64(m.TimestampMicro))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovGroupApi(uint64(l))
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovGroupApi(uint64(l))
	}
	return n
}

func (m *DeleteResponse) Size() (n int) {
	var l int
	_ = l
	if m.Rpcid != 0 {
		n += 1 + sovGroupApi(uint64(m.Rpcid))
	}
	if m.TimestampMicro != 0 {
		n += 1 + sovGroupApi(uint64(m.TimestampMicro))
	}
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovGroupApi(uint64(l))
	}
	return n
}

func sovGroupApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGroupApi(x uint64) (n int) {
	return sovGroupApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EmptyMsg) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmptyMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmptyMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyA", wireType)
			}
			m.KeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyB", wireType)
			}
			m.KeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyA", wireType)
			}
			m.ChildKeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyB", wireType)
			}
			m.ChildKeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], data[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMicro", wireType)
			}
			m.TimestampMicro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimestampMicro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookupRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyA", wireType)
			}
			m.KeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyB", wireType)
			}
			m.KeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyA", wireType)
			}
			m.ChildKeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyB", wireType)
			}
			m.ChildKeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyA", wireType)
			}
			m.KeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyB", wireType)
			}
			m.KeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyA", wireType)
			}
			m.ChildKeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyB", wireType)
			}
			m.ChildKeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyA", wireType)
			}
			m.KeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyB", wireType)
			}
			m.KeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyA", wireType)
			}
			m.ChildKeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyB", wireType)
			}
			m.ChildKeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMicro", wireType)
			}
			m.TimestampMicro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimestampMicro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookupGroupRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookupGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookupGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyA", wireType)
			}
			m.KeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyB", wireType)
			}
			m.KeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadGroupRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadGroupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadGroupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyA", wireType)
			}
			m.KeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyB", wireType)
			}
			m.KeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMicro", wireType)
			}
			m.TimestampMicro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimestampMicro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookupResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMicro", wireType)
			}
			m.TimestampMicro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimestampMicro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Length |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookupGroupResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookupGroupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookupGroupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &LookupGroupItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LookupGroupItem) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LookupGroupItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LookupGroupItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyA", wireType)
			}
			m.ChildKeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyB", wireType)
			}
			m.ChildKeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMicro", wireType)
			}
			m.TimestampMicro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimestampMicro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Length |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadGroupResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadGroupResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadGroupResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ReadGroupItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadGroupItem) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadGroupItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadGroupItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyA", wireType)
			}
			m.ChildKeyA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyA |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildKeyB", wireType)
			}
			m.ChildKeyB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ChildKeyB |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMicro", wireType)
			}
			m.TimestampMicro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimestampMicro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], data[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMicro", wireType)
			}
			m.TimestampMicro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimestampMicro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], data[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rpcid", wireType)
			}
			m.Rpcid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rpcid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimestampMicro", wireType)
			}
			m.TimestampMicro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimestampMicro |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroupApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroupApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroupApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGroupApi(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGroupApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGroupApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGroupApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGroupApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGroupApi(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGroupApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGroupApi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("group_api.proto", fileDescriptorGroupApi) }

var fileDescriptorGroupApi = []byte{
	// 625 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xcc, 0x56, 0xcf, 0x6e, 0xd3, 0x4e,
	0x10, 0xee, 0xc6, 0x76, 0xfa, 0xcb, 0x24, 0x4e, 0xd2, 0xfd, 0x21, 0x70, 0x4a, 0x09, 0x91, 0x0f,
	0xc8, 0xa7, 0x00, 0xe5, 0x88, 0x84, 0xd4, 0x88, 0x8a, 0x3f, 0xa5, 0x52, 0xb5, 0x45, 0x42, 0xe2,
	0x52, 0x42, 0xb2, 0x4a, 0xad, 0xc6, 0xb5, 0xb1, 0x37, 0x88, 0x3e, 0x01, 0x82, 0x27, 0xe0, 0xc6,
	0x81, 0x27, 0xe0, 0x25, 0x10, 0x47, 0x1e, 0x01, 0x85, 0x17, 0x41, 0xde, 0x8d, 0x9d, 0x75, 0x6c,
	0xa7, 0x12, 0x31, 0x0a, 0x37, 0xef, 0xce, 0xe8, 0x9b, 0x6f, 0x67, 0xbe, 0x6f, 0x12, 0x68, 0x8c,
	0x7c, 0x77, 0xe2, 0x9d, 0xf4, 0x3d, 0xbb, 0xeb, 0xf9, 0x2e, 0x73, 0x31, 0xf0, 0x0b, 0xfe, 0x6d,
	0x02, 0xfc, 0xb7, 0xef, 0x78, 0xec, 0xe2, 0x30, 0x18, 0x99, 0xdf, 0x10, 0xd4, 0x5e, 0xf8, 0x36,
	0xa3, 0x84, 0xbe, 0x99, 0xd0, 0x80, 0xe1, 0x2b, 0xa0, 0xf9, 0xde, 0xc0, 0x1e, 0x1a, 0xa8, 0x83,
	0x2c, 0x9d, 0x88, 0x03, 0xc6, 0xa0, 0x9e, 0xd1, 0x8b, 0x3d, 0xa3, 0xd4, 0x41, 0x96, 0x4a, 0xf8,
	0xf7, 0xec, 0xae, 0x67, 0x28, 0xf1, 0x5d, 0x0f, 0xef, 0x40, 0x65, 0x70, 0x6a, 0x8f, 0x87, 0x07,
	0x61, 0xb2, 0xca, 0x03, 0xf3, 0x0b, 0x39, 0xda, 0x33, 0xb4, 0x64, 0xb4, 0x17, 0x56, 0x7e, 0xdb,
	0x1f, 0x4f, 0xa8, 0x51, 0xee, 0x20, 0xab, 0x46, 0xc4, 0x01, 0xdf, 0x82, 0x3a, 0xb3, 0x1d, 0x1a,
	0xb0, 0xbe, 0xe3, 0x1d, 0xda, 0x03, 0xdf, 0x35, 0x36, 0x3b, 0xc8, 0x52, 0xc8, 0xc2, 0xad, 0xf9,
	0x01, 0x81, 0xfe, 0xcc, 0x75, 0xcf, 0x26, 0xde, 0xda, 0x5f, 0x62, 0xbe, 0x47, 0x50, 0x25, 0xb4,
	0x3f, 0x5c, 0x3f, 0x93, 0xaf, 0x08, 0xf4, 0x87, 0x74, 0x4c, 0xff, 0x85, 0xf9, 0xa6, 0x27, 0x59,
	0xce, 0x9c, 0x24, 0x01, 0x2c, 0x06, 0xf9, 0x28, 0x94, 0x6c, 0x21, 0xbc, 0xcd, 0x23, 0x68, 0x86,
	0x03, 0x29, 0x10, 0xf1, 0x04, 0xf4, 0x99, 0x6f, 0x02, 0xcf, 0x3d, 0x0f, 0x68, 0x0e, 0x5c, 0xfa,
	0xd1, 0xa5, 0xac, 0x47, 0xe3, 0x26, 0x28, 0xd4, 0xf7, 0x79, 0x85, 0x0a, 0x09, 0x3f, 0xcd, 0x77,
	0x50, 0x8f, 0xf4, 0x5c, 0x48, 0x85, 0xab, 0x50, 0x1e, 0xd3, 0xf3, 0x11, 0x3b, 0xe5, 0x45, 0x74,
	0x32, 0x3b, 0x45, 0x95, 0xd5, 0x79, 0x65, 0x0f, 0xfe, 0x4f, 0x0c, 0x60, 0x69, 0xf9, 0xbb, 0xa0,
	0xd9, 0x8c, 0x3a, 0x81, 0x51, 0xea, 0x28, 0x56, 0x75, 0xf7, 0x7a, 0x77, 0xbe, 0x68, 0xba, 0x12,
	0xca, 0x13, 0x46, 0x1d, 0x22, 0x32, 0x33, 0xde, 0xfa, 0x05, 0x41, 0x63, 0x21, 0x39, 0xa7, 0x5c,
	0x42, 0x80, 0xa5, 0xa5, 0x02, 0x54, 0x2e, 0x17, 0xa0, 0x7a, 0x49, 0xa7, 0x34, 0xb9, 0x53, 0xe6,
	0x18, 0xb6, 0x24, 0x11, 0x2d, 0xed, 0xca, 0xed, 0x64, 0x57, 0x5a, 0x72, 0x57, 0x62, 0x8c, 0xe5,
	0x3d, 0xf9, 0x8c, 0x40, 0x4f, 0xa4, 0xae, 0xb1, 0x23, 0xf1, 0x6a, 0xd6, 0xa4, 0xd5, 0x6c, 0x32,
	0xa8, 0x89, 0x2d, 0x57, 0x88, 0x3e, 0xe3, 0x1a, 0x8a, 0xbc, 0xfe, 0xd3, 0xea, 0x7c, 0x05, 0xf5,
	0x68, 0xa3, 0xfd, 0x1d, 0xe7, 0xed, 0x7e, 0xdc, 0x04, 0xe0, 0x5d, 0x3f, 0x66, 0xae, 0x4f, 0xf1,
	0x03, 0xd0, 0xb8, 0xd3, 0xb1, 0x21, 0x4f, 0x51, 0xfe, 0xd1, 0xdc, 0x6e, 0x65, 0x44, 0x04, 0x39,
	0x73, 0x03, 0x3f, 0x86, 0xea, 0x31, 0xf3, 0x69, 0xdf, 0x59, 0x05, 0xc5, 0x42, 0x77, 0x10, 0xde,
	0x83, 0xb2, 0x70, 0x09, 0x6e, 0xa5, 0x6d, 0x16, 0xa1, 0x6c, 0x67, 0x85, 0x62, 0x32, 0x07, 0x50,
	0x13, 0x64, 0x56, 0x04, 0xe2, 0x7c, 0x8e, 0xa0, 0x2a, 0xb9, 0x16, 0xb7, 0x73, 0xbc, 0x1f, 0x01,
	0xde, 0xcc, 0x8d, 0xc7, 0xf4, 0x5e, 0xc2, 0x96, 0x4c, 0xaf, 0x28, 0x5c, 0xce, 0xf6, 0x29, 0x54,
	0x62, 0x3f, 0xe1, 0x9d, 0x4c, 0x47, 0x46, 0x88, 0x37, 0x72, 0xa2, 0x31, 0xcf, 0xe7, 0xd0, 0x10,
	0x3c, 0x8b, 0x42, 0xe4, 0x0c, 0xef, 0x83, 0x1a, 0x86, 0xf0, 0xb5, 0xc5, 0xe4, 0x08, 0xc5, 0x48,
	0x07, 0x62, 0x4a, 0xfb, 0x00, 0x73, 0x4a, 0x7f, 0x04, 0x11, 0x69, 0x4c, 0xd8, 0x2b, 0x29, 0x8d,
	0xc4, 0x9f, 0x88, 0xa4, 0x34, 0x92, 0x6e, 0x94, 0x35, 0xb6, 0x22, 0x50, 0xc8, 0xa7, 0xd7, 0xfc,
	0x3e, 0x6d, 0xa3, 0x1f, 0xd3, 0x36, 0xfa, 0x39, 0x6d, 0xa3, 0x4f, 0xbf, 0xda, 0x1b, 0xaf, 0xcb,
	0x3c, 0xfb, 0xde, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1c, 0xae, 0x4e, 0x46, 0xe4, 0x0a, 0x00,
	0x00,
}
